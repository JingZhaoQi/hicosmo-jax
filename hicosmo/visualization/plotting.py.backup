#!/usr/bin/env python3
"""
HIcosmo Minimalist Visualization System - Core Plotting Functions

Radical simplification based on Occam's Razor:
- Removed all Manager classes and over-abstraction
- Direct GetDist wrapper without intermediate layers
- Unified concise function interface
- Built-in professional styling without complex configuration

Author: Jingzhao Qi
Total Lines: ~400 (vs original 3818 lines)
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from pathlib import Path
from typing import Dict, List, Optional, Union, Any, Tuple

try:
    from getdist import plots, MCSamples
    HAS_GETDIST = True
except ImportError:
    HAS_GETDIST = False
    raise ImportError("GetDist is required. Install with: pip install getdist")

# Professional color schemes - based on analysis/core.py
MODERN_COLORS = ['#2E86AB', '#A23B72', '#F18F01', '#C73E1D', '#592E83', '#0F7173', '#7B2D26']
CLASSIC_COLORS = ['#348ABD', '#7A68A6', '#E24A33', '#467821', '#ffb3a6', '#188487', '#A60628']

# LaTeX标签映射 - 只保留常用的
LATEX_LABELS = {
    'H0': r'H_0 ~[\mathrm{km~s^{-1}~Mpc^{-1}}]',
    'Omega_m': r'\Omega_m',
    'Omega_b': r'\Omega_b',
    'sigma8': r'\sigma_8',
    'w': r'w',
    'w0': r'w_0',
    'wa': r'w_a',
}

# 默认保存目录 - 相对于调用脚本的位置
def _get_results_dir():
    """获取相对于调用脚本的results目录"""
    import inspect
    frame = inspect.currentframe()
    try:
        # 获取调用栈中第一个非visualization模块的帧
        caller_frame = frame.f_back.f_back if frame.f_back else frame.f_back
        if caller_frame and 'visualization' not in caller_frame.f_code.co_filename:
            caller_dir = Path(caller_frame.f_code.co_filename).parent
        else:
            caller_dir = Path.cwd()
        results_dir = caller_dir / 'results'
        results_dir.mkdir(exist_ok=True)
        return results_dir
    finally:
        del frame

RESULTS_DIR = Path('results')  # fallback
RESULTS_DIR.mkdir(exist_ok=True)

def _apply_qijing_style():
    """应用你的专业绘图风格 - 基于FigStyle.py"""
    import seaborn as sns

    # 基础样式配置 (合并自原来5套样式的最佳部分)
    style_config = {
        'axes.linewidth': 1.2,
        'axes.labelsize': 16,
        'axes.titlesize': 16,
        'xtick.labelsize': 11,
        'ytick.labelsize': 11,
        'legend.fontsize': 14,
        'legend.frameon': False,  # 关键：无边框图例
        'figure.facecolor': 'white',
        'axes.facecolor': 'white',
        'savefig.facecolor': 'white',
        'font.size': 12,
        'lines.linewidth': 2.0,
        'axes.grid': True,
        'grid.alpha': 0.3,
        'mathtext.fontset': 'cm',
        'mathtext.rm': 'serif',
    }

    plt.rcParams.update(style_config)

    # 设置颜色循环
    plt.rcParams['axes.prop_cycle'] = plt.cycler(color=MODERN_COLORS)

def _optimize_ticks(fig):
    """智能刻度优化 - 基于analysis/core.py"""
    for ax in fig.axes:
        if hasattr(ax, 'xaxis') and hasattr(ax, 'yaxis'):
            # 根据子图尺寸自适应刻度数量
            bbox = ax.get_position()
            width_inch = bbox.width * fig.get_figwidth()
            height_inch = bbox.height * fig.get_figheight()

            x_nbins = 3 if width_inch < 1.5 else (4 if width_inch < 2.5 else 5)
            y_nbins = 3 if height_inch < 1.5 else (4 if height_inch < 2.5 else 5)

            ax.xaxis.set_major_locator(ticker.MaxNLocator(nbins=x_nbins, prune='both', min_n_ticks=2))
            ax.yaxis.set_major_locator(ticker.MaxNLocator(nbins=y_nbins, prune='both', min_n_ticks=2))

            # 小子图旋转标签
            if width_inch < 1.8:
                plt.setp(ax.get_xticklabels(), rotation=45, ha='right')

def _load_chain_data(data) -> Tuple[np.ndarray, List[str]]:
    """
    简单数据加载 - 替代复杂的ChainManager

    Parameters
    ----------
    data : various
        链数据，支持多种格式

    Returns
    -------
    samples : np.ndarray
        样本数组 (n_samples, n_params)
    param_names : list
        参数名列表
    """
    if isinstance(data, str):
        # 文件路径
        file_path = Path(data)
        if file_path.suffix == '.npy':
            samples = np.load(file_path)
            param_names = [f'param_{i}' for i in range(samples.shape[1])]
        else:
            raise ValueError(f"Unsupported file format: {file_path.suffix}")

    elif isinstance(data, dict):
        # 字典格式 {'H0': array, 'Omega_m': array}
        param_names = list(data.keys())
        samples = np.column_stack([data[p] for p in param_names])

    elif hasattr(data, 'samples') and hasattr(data, 'params'):
        # ChainData对象
        samples = data.samples
        param_names = data.params

    elif isinstance(data, np.ndarray):
        # 直接数组
        samples = data
        param_names = [f'param_{i}' for i in range(data.shape[1])]

    else:
        raise ValueError(f"Unsupported data format: {type(data)}")

    return samples, param_names

def _prepare_getdist_samples(data, params=None, label="Chain") -> MCSamples:
    """
    转换为GetDist格式 - 替代复杂的适配器
    """
    samples, param_names = _load_chain_data(data)

    # 选择参数
    if params is not None:
        if isinstance(params, (int, str)):
            params = [params]

        # 处理索引或名称
        selected_indices = []
        selected_names = []

        for p in params:
            if isinstance(p, int):
                # 基于1的索引转为基于0的索引
                idx = p - 1 if p > 0 else p
                selected_indices.append(idx)
                selected_names.append(param_names[idx])
            else:
                # 参数名
                if p in param_names:
                    idx = param_names.index(p)
                    selected_indices.append(idx)
                    selected_names.append(p)

        samples = samples[:, selected_indices]
        param_names = selected_names

    # 准备LaTeX标签
    labels = []
    for param in param_names:
        latex_label = LATEX_LABELS.get(param, param)
        # 清理多余的$符号
        if latex_label.startswith('$') and latex_label.endswith('$'):
            latex_label = latex_label[1:-1]
        labels.append(latex_label)

    return MCSamples(samples=samples, names=param_names, labels=labels, label=label)

def plot_corner(data, params=None, style='modern', filename=None, labels=None, **kwargs) -> plt.Figure:
    """
    创建Corner图 - 统一简洁接口，支持多链对比

    Parameters
    ----------
    data : various or list of various
        单链：链数据 (文件路径、数组、字典、ChainData对象)
        多链：[data1, data2, ...] 多链数据列表
    params : list, optional
        要绘制的参数 (索引或名称)
    style : str
        配色方案 ('modern' 或 'classic')
    filename : str, optional
        保存文件名 (自动保存到调用代码所在目录的results/)
    labels : list of str, optional
        多链情况下的标签列表 ['Chain1', 'Chain2', ...]
    **kwargs
        传递给GetDist的参数

    Returns
    -------
    fig : plt.Figure
        Corner图，支持多链对比和图例
    """
    # 应用样式
    _apply_qijing_style()

    # 选择配色
    colors = MODERN_COLORS if style == 'modern' else CLASSIC_COLORS

    # 检测是否为多链数据
    is_multi_chain = isinstance(data, (list, tuple)) and len(data) > 1

    if is_multi_chain:
        # 多链模式
        samples_list = []
        for i, chain_data in enumerate(data):
            samples = _prepare_getdist_samples(chain_data, params)
            # 设置标签
            if labels and i < len(labels):
                samples.label = labels[i]
            else:
                samples.label = f'Chain {i+1}'
            samples_list.append(samples)

        # 为每个链分配不同颜色
        contour_colors = colors[:len(samples_list)]
        line_colors = colors[:len(samples_list)]
    else:
        # 单链模式 - 向后兼容
        samples = _prepare_getdist_samples(data, params)
        samples_list = [samples]
        contour_colors = [colors[0]]
        line_colors = [colors[0]]

    # 创建GetDist绘图器
    plotter = plots.get_subplot_plotter(width_inch=8)

    # GetDist专业设置
    plotter.settings.axes_fontsize = 12
    plotter.settings.lab_fontsize = 14
    plotter.settings.legend_fontsize = 12
    plotter.settings.figure_legend_frame = False

    # 绘制corner图
    if is_multi_chain:
        # 多链绘制 - 使用不同颜色和图例
        plotter.triangle_plot(samples_list, filled=True,
                             contour_colors=contour_colors,
                             line_args=[{'color': c, 'lw': 2} for c in line_colors],
                             **kwargs)
        # 添加图例
        if any(s.label for s in samples_list):
            plotter.add_legend(legend_labels=[s.label for s in samples_list],
                              legend_loc='upper right')
    else:
        # 单链绘制
        plotter.triangle_plot(samples_list, filled=True,
                             contour_colors=contour_colors,
                             line_args={'color': line_colors[0], 'lw': 2},
                             **kwargs)

    # 优化刻度
    _optimize_ticks(plotter.fig)
    plt.tight_layout()

    # 自动保存到调用代码所在目录的results/
    if filename:
        results_dir = _get_results_dir()
        save_path = results_dir / filename
        if not save_path.suffix:
            save_path = save_path.with_suffix('.pdf')

        save_path.parent.mkdir(parents=True, exist_ok=True)
        plotter.fig.savefig(save_path, dpi=300, bbox_inches='tight',
                           facecolor='white', edgecolor='none')
        print(f"Corner plot saved to: {save_path}")

    return plotter.fig

def plot_chains(data, params=None, style='modern', filename=None, **kwargs) -> plt.Figure:
    """
    创建链迹线图 - 收敛诊断

    Parameters
    ----------
    data : various
        链数据
    params : list, optional
        要绘制的参数
    style : str
        配色方案
    filename : str, optional
        保存文件名
    **kwargs
        额外参数

    Returns
    -------
    fig : plt.Figure
        迹线图
    """
    _apply_qijing_style()

    # 加载数据
    samples, param_names = _load_chain_data(data)

    # 选择参数
    if params is not None:
        if isinstance(params, (int, str)):
            params = [params]

        selected_indices = []
        selected_names = []

        for p in params:
            if isinstance(p, int):
                idx = p - 1 if p > 0 else p
                selected_indices.append(idx)
                selected_names.append(param_names[idx])
            else:
                if p in param_names:
                    idx = param_names.index(p)
                    selected_indices.append(idx)
                    selected_names.append(p)

        samples = samples[:, selected_indices]
        param_names = selected_names

    # 选择配色
    colors = MODERN_COLORS if style == 'modern' else CLASSIC_COLORS

    # 创建图像
    n_params = len(param_names)
    fig, axes = plt.subplots(n_params, 1, figsize=(10, max(4, n_params * 2)), squeeze=False)

    for i, param in enumerate(param_names):
        ax = axes[i, 0]

        # 绘制迹线
        ax.plot(samples[:, i], color=colors[0], alpha=0.8, lw=1.0)

        # 设置标签
        latex_label = LATEX_LABELS.get(param, param)
        if latex_label.startswith('$') and latex_label.endswith('$'):
            latex_label = latex_label[1:-1]

        ax.set_ylabel(f'${latex_label}$' if '\\' in latex_label else latex_label)
        ax.grid(True, alpha=0.3)

        if i == n_params - 1:
            ax.set_xlabel('Sample')

    plt.tight_layout()

    # 自动保存
    if filename:
        save_path = RESULTS_DIR / filename
        if not save_path.suffix:
            save_path = save_path.with_suffix('.pdf')

        save_path.parent.mkdir(parents=True, exist_ok=True)
        fig.savefig(save_path, dpi=300, bbox_inches='tight',
                   facecolor='white', edgecolor='none')
        print(f"Chain traces saved to: {save_path}")

    return fig

def plot_1d(data, params=None, style='modern', filename=None, **kwargs) -> plt.Figure:
    """
    创建1D边际分布图

    Parameters
    ----------
    data : various
        链数据
    params : list, optional
        要绘制的参数
    style : str
        配色方案
    filename : str, optional
        保存文件名
    **kwargs
        传递给GetDist的参数

    Returns
    -------
    fig : plt.Figure
        1D分布图
    """
    _apply_qijing_style()

    colors = MODERN_COLORS if style == 'modern' else CLASSIC_COLORS
    samples = _prepare_getdist_samples(data, params)

    # 创建GetDist绘图器
    plotter = plots.getSubplotPlotter()
    plotter.settings.figure_legend_frame = False

    # 绘制1D分布
    plotter.plots_1d([samples], **kwargs)

    # 自动保存
    if filename:
        save_path = RESULTS_DIR / filename
        if not save_path.suffix:
            save_path = save_path.with_suffix('.pdf')

        save_path.parent.mkdir(parents=True, exist_ok=True)
        plotter.fig.savefig(save_path, dpi=300, bbox_inches='tight',
                           facecolor='white', edgecolor='none')
        print(f"1D plots saved to: {save_path}")

    return plotter.fig

# 向后兼容的别名
corner = plot_corner
traces = plot_chains
marginals = plot_1d